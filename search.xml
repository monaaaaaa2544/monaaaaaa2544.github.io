<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Latex标签总结</title>
    <url>/2022/03/16/Latex%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Latex标签总结</p>
<span id="more"></span>

<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\vspace&#123;2.5cm&#125; 垂直间距</span><br><span class="line">\hspace&#123;2.5cm&#125; 水平间距</span><br></pre></td></tr></table></figure>

<h2 id="插入参考文献"><a href="#插入参考文献" class="headerlink" title="插入参考文献"></a>插入参考文献</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\bibliographystyle&#123;IEEEtran&#125;   //IEEEtran为给定模板格式定义文件名</span><br><span class="line"></span><br><span class="line">\bibliography&#123;ref&#125;           //ref为.bib文件名</span><br></pre></td></tr></table></figure>

<h2 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;algorithm&#125;  </span><br><span class="line">\usepackage&#123;algorithmicx&#125;  </span><br><span class="line">\usepackage&#123;algpseudocode&#125;</span><br></pre></td></tr></table></figure>
<p>不要再使用algorithmic，使用如上三个就可以</p>
<h2 id="插入图片及排版方法"><a href="#插入图片及排版方法" class="headerlink" title="插入图片及排版方法"></a>插入图片及排版方法</h2><h3 id="跨栏放置图片"><a href="#跨栏放置图片" class="headerlink" title="跨栏放置图片"></a>跨栏放置图片</h3><p>在论文排版为双栏时，需要跨栏放置图片，只需要在 <code>\begin&#123;figure&#125;</code> 和 <code>&#123;\end&#123;figure&#125;&#125;</code> 上带星号 <code>*</code> 即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a herf='https://blog.csdn.net/qq_31347869/article/details/103832190' >LaTex笔记一：图片的插入及排版方法</a> </p>
]]></content>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2022/03/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>记录一些常用的Linux命令</p>
<span id="more"></span>


<h3 id="查看gpu资源使用情况"><a href="#查看gpu资源使用情况" class="headerlink" title="查看gpu资源使用情况"></a>查看gpu资源使用情况</h3><p>watch -n1 gpustat -cpu </p>
<h3 id="查看文件目录下的文件数有多少"><a href="#查看文件目录下的文件数有多少" class="headerlink" title="查看文件目录下的文件数有多少"></a>查看文件目录下的文件数有多少</h3><p>ls -lR| grep “^-“ | wc -l</p>
<h3 id="解压文件到一个文件夹下"><a href="#解压文件到一个文件夹下" class="headerlink" title="解压文件到一个文件夹下"></a>解压文件到一个文件夹下</h3><p>tar -xvf 文件名   </p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>mv 起始路径 目标路径</p>
<h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><p>mv 文件名 文件名</p>
<h3 id="把本地的jpeg文件拷贝到服务器上的ISIC目录下"><a href="#把本地的jpeg文件拷贝到服务器上的ISIC目录下" class="headerlink" title="把本地的jpeg文件拷贝到服务器上的ISIC目录下"></a>把本地的jpeg文件拷贝到服务器上的ISIC目录下</h3><p>scp -r D:&#x2F;各种文档&#x2F;研究生&#x2F;代码&#x2F;data&#x2F;jpeg&#x2F; <a href="mailto:&#120;&#x69;&#110;&#121;&#117;&#x61;&#110;&#64;&#x31;&#55;&#50;&#x2e;&#x33;&#49;&#46;&#x32;&#x32;&#x36;&#46;&#49;&#53;&#54;">&#120;&#x69;&#110;&#121;&#117;&#x61;&#110;&#64;&#x31;&#55;&#50;&#x2e;&#x33;&#49;&#46;&#x32;&#x32;&#x36;&#46;&#49;&#53;&#54;</a>:&#x2F;home&#x2F;data&#x2F;xinyuan&#x2F;adv_train_wbc&#x2F;data&#x2F;ISIC&#x2F; </p>
<h3 id="把192-168-0-10机器上的source-txt文件拷贝到本地的-x2F-home-x2F-work目录下"><a href="#把192-168-0-10机器上的source-txt文件拷贝到本地的-x2F-home-x2F-work目录下" class="headerlink" title="把192.168.0.10机器上的source.txt文件拷贝到本地的&#x2F;home&#x2F;work目录下"></a>把192.168.0.10机器上的source.txt文件拷贝到本地的&#x2F;home&#x2F;work目录下</h3><p>scp <a href="mailto:&#119;&#111;&#114;&#x6b;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#46;&#x30;&#x2e;&#x31;&#x30;">&#119;&#111;&#114;&#x6b;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#x36;&#56;&#46;&#x30;&#x2e;&#x31;&#x30;</a>:&#x2F;home&#x2F;work&#x2F;source.txt &#x2F;home&#x2F;work&#x2F;   </p>
<h3 id="把192-168-0-10机器上的source-txt文件拷贝到192-168-0-11机器的-x2F-home-x2F-work目录下"><a href="#把192-168-0-10机器上的source-txt文件拷贝到192-168-0-11机器的-x2F-home-x2F-work目录下" class="headerlink" title="把192.168.0.10机器上的source.txt文件拷贝到192.168.0.11机器的&#x2F;home&#x2F;work目录下"></a>把192.168.0.10机器上的source.txt文件拷贝到192.168.0.11机器的&#x2F;home&#x2F;work目录下</h3><p>scp <a href="mailto:&#119;&#x6f;&#x72;&#107;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#x30;&#x2e;&#49;&#x30;">&#119;&#x6f;&#x72;&#107;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#x30;&#x2e;&#49;&#x30;</a>:&#x2F;home&#x2F;work&#x2F;source.txt <a href="mailto:&#x77;&#111;&#114;&#107;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#x36;&#x38;&#46;&#x30;&#46;&#x31;&#x31;">&#x77;&#111;&#114;&#107;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#x36;&#x38;&#46;&#x30;&#46;&#x31;&#x31;</a>:&#x2F;home&#x2F;work&#x2F;   </p>
<h3 id="拷贝文件夹，加-r参数-拷贝整个目录"><a href="#拷贝文件夹，加-r参数-拷贝整个目录" class="headerlink" title="拷贝文件夹，加-r参数(拷贝整个目录)"></a>拷贝文件夹，加-r参数(拷贝整个目录)</h3><p>scp -r &#x2F;home&#x2F;work&#x2F;sourcedir <a href="mailto:&#x77;&#x6f;&#x72;&#x6b;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#54;&#56;&#x2e;&#48;&#46;&#x31;&#x30;">&#x77;&#x6f;&#x72;&#x6b;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#54;&#56;&#x2e;&#48;&#46;&#x31;&#x30;</a>:&#x2F;home&#x2F;work&#x2F;   </p>
<h3 id="png-jpg图像转换为矢量图-eps-c保证转换后保证图像彩色"><a href="#png-jpg图像转换为矢量图-eps-c保证转换后保证图像彩色" class="headerlink" title=".png .jpg图像转换为矢量图 .eps -c保证转换后保证图像彩色"></a>.png .jpg图像转换为矢量图 .eps <code>-c</code>保证转换后保证图像彩色</h3><p>bmeps -c .\diff_adv_clean_pgd4.png diff.eps  </p>
<h3 id="后台运行命令"><a href="#后台运行命令" class="headerlink" title="后台运行命令"></a>后台运行命令</h3><p>nohup COMMAND &amp;<br>nohup sh test.sh &amp;</p>
<h3 id="后台运行命令-不记录任何日志"><a href="#后台运行命令-不记录任何日志" class="headerlink" title="后台运行命令(不记录任何日志)"></a>后台运行命令(不记录任何日志)</h3><p>nohup python gp&#x2F;trained.py -w 35 &gt;&#x2F;dev&#x2F;null  2&gt;&amp;1 &amp;</p>
<h3 id="查看后台运行的进程列表"><a href="#查看后台运行的进程列表" class="headerlink" title="查看后台运行的进程列表"></a>查看后台运行的进程列表</h3><p>jobs</p>
<h3 id="将后台运行的命令放到前台继续运行"><a href="#将后台运行的命令放到前台继续运行" class="headerlink" title="将后台运行的命令放到前台继续运行"></a>将后台运行的命令放到前台继续运行</h3><p>fg %jobname </p>
<h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>htop  Linux系统中的一个互动的进程查看器<br>与top相比，htop有以下优点：</p>
<ul>
<li>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</li>
<li>在启动上，比top 更快。</li>
<li>杀进程时不需要输入进程号。</li>
<li>htop 支持鼠标操作。</li>
<li>两者相比起来，top比较繁琐。</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3项目时出过的错</title>
    <url>/2022/03/12/Vue3%E4%B8%AD%E4%BD%BF%E7%94%A8TS%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<p>写Vue3项目时出过的错</p>
<span id="more"></span>

<ol>
<li><p>store中的变量都命成响应式</p>
</li>
<li><p>prop传入的值直接使用，不用用变量接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 以下是错误的 --&gt;</span><br><span class="line">&lt;li v-for=&quot;tag in tagList&quot; :key=&quot;tag.id&quot;</span><br><span class="line">                            :class=&quot;&#123;selected: selectedTags.indexOf(tag)&gt;=0&#125;&quot;</span><br><span class="line">                            @click=&quot;toggle(tag)&quot;&gt;</span><br><span class="line">                        &#123;&#123;tag.name&#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">const tagList=reactive&lt;any&gt;(props.tags) </span><br></pre></td></tr></table></figure>
</li>
<li><p>@绑定的方法，不用传入值，直接用event.target.xx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function inputContent(evt: MouseEvent)&#123;</span><br><span class="line">    input = evt.target.innerHTML;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Vue3中父子组件传值</title>
    <url>/2022/03/09/Vue3%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><ul>
<li>父组件给子组件传值用defineProps</li>
<li>子组件给父组件传值用defineEmits<span id="more"></span></li>
</ul>
<h2 id="二、父组件给子组件传值"><a href="#二、父组件给子组件传值" class="headerlink" title="二、父组件给子组件传值"></a>二、父组件给子组件传值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;Types v-model:type=&quot;record.type&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">const props=defineProps(&#123;</span><br><span class="line">    type: String</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(props.type)</span><br></pre></td></tr></table></figure>

<h2 id="三、子组件给父组件传值"><a href="#三、子组件给父组件传值" class="headerlink" title="三、子组件给父组件传值"></a>三、子组件给父组件传值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;Types v-model:type=&quot;record.type&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">const emit=defineEmits&lt;&#123;</span><br><span class="line">    (event: &#x27;update:type&#x27;, types: string): void</span><br><span class="line">&#125;&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href='https://mp.weixin.qq.com/s/pUYCDIIk4GQ5DeIjAuEdBQ'>Vue3.2 中的 setup 语法糖，保证你看的明明白白！</a></p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Web中数据的保存</title>
    <url>/2022/03/09/Web%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%9D%E5%AD%98/</url>
    <content><![CDATA[<h2 id="一、几种数据保存方法"><a href="#一、几种数据保存方法" class="headerlink" title="一、几种数据保存方法"></a>一、几种数据保存方法</h2><ul>
<li>LocalStorage</li>
<li>Vuex<span id="more"></span></li>
</ul>
<h2 id="二、LocalStorage"><a href="#二、LocalStorage" class="headerlink" title="二、LocalStorage"></a>二、LocalStorage</h2><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(&quot;name&quot;, JSON.stringify(data))</span><br></pre></td></tr></table></figure>
<p>注意这里保存的data是字符串格式，所以需要用<code>JSON.stringify()</code>转换成字符格式</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON.parse(localStorage.getItem(localStorageKeyName))</span><br></pre></td></tr></table></figure>
<p>读取数据时也需要用<code>JSON.parse()</code>解析字符串</p>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>TS语法</title>
    <url>/2022/03/10/TS%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>总结TS的语法</p>
<span id="more"></span>



<h2 id="推荐查阅"><a href="#推荐查阅" class="headerlink" title="推荐查阅"></a>推荐查阅</h2><p><a href='https://www.tslang.cn/docs/handbook/basic-types.html'>TS官方文档</a><br><a href='https://mp.weixin.qq.com/s/pQNCLOZWsqXi6NScyWhdEg'>微信公众号的总结</a><br><a href='https://time.geekbang.org/course/detail/211-128376'>TS开发实战</a><br><a href='https://mp.weixin.qq.com/s/pUYCDIIk4GQ5DeIjAuEdBQ'>Vue3.2 中的 setup 语法糖，保证你看的明明白白！</a></p>
<h2 id="TS基础"><a href="#TS基础" class="headerlink" title="TS基础"></a>TS基础</h2><p><a href="https://imgtu.com/i/bh2YsP"><img src="https://s1.ax1x.com/2022/03/10/bh2YsP.md.png" alt="bh2YsP.md.png"></a></p>
<h2 id="TS介绍"><a href="#TS介绍" class="headerlink" title="TS介绍"></a>TS介绍</h2><p>Typescript是静态弱类型语言。</p>
<ul>
<li>静态是指在编译是会检查变量类型，动态是在执行时才检查，所以动态类型的语言运行速度慢</li>
<li>弱类型是指当一个变量已经被定义了类型，但是可根据环境变化自动转换，不需要强制转换</li>
</ul>
<p>关于各种语言类型的分类可查阅：<a href="https://www.zhihu.com/question/19918532">https://www.zhihu.com/question/19918532</a></p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JS八种内置类型：string、number、Boolean、bigint、null、undefined、symbol、object<br>ECMAScript 的内置对象：Array Date Error<br>DOM 和 BOM: HTMLElement、NodeList、MouseEvent<br>TS 核心库的定义文件: Math.pow addEventListener</p>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>interface是TS设计出来用于定义对象类型的</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>public: 公有的。能被实例化、子类继承<br>private: 私有的。只属于这个类自己，它的实例和子类都访问不到<br>protected：被保护的。子类可以访问，实例不能访问<br>static：静态属性。类上的一些常量，实例和子类都不能访问<br>抽象类：只能被继承不能实例化的类<br>抽象方法：必须在子类中实现<br>多态：父类定义一个抽象方法，在多个子类中有不同的实现</p>
<h3 id="接口和类的关系"><a href="#接口和类的关系" class="headerlink" title="接口和类的关系"></a>接口和类的关系</h3><ol>
<li>类实现接口<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface StudentInterface&#123;</span><br><span class="line">    sayName(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements StudentInterface&#123;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(&#x27;say Name&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="TS进阶"><a href="#TS进阶" class="headerlink" title="TS进阶"></a>TS进阶</h2><p><a href="https://imgtu.com/i/bHbU8H"><img src="https://s1.ax1x.com/2022/03/12/bHbU8H.md.png" alt="bHbU8H.md.png"></a></p>
<h2 id="TS实战"><a href="#TS实战" class="headerlink" title="TS实战"></a>TS实战</h2><h3 id="Vue3-todoList"><a href="#Vue3-todoList" class="headerlink" title="Vue3 todoList"></a>Vue3 todoList</h3><p>涉及知识</p>
<ul>
<li>Vue3</li>
<li>script setup</li>
<li>ref</li>
<li>computed</li>
<li>条件渲染和列表渲染</li>
<li>数据绑定和 v-model</li>
<li>事件</li>
</ul>
<p>TS</p>
<ul>
<li>基础类型</li>
<li>接口</li>
<li>泛型</li>
<li>TS 结合 Vue3</li>
</ul>
<p>要实现的功能</p>
<ul>
<li>新增待办事项</li>
<li>删除待办事项</li>
<li>全选和取消全选功能</li>
<li>清理已做事项</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>如果函数的返回值是由输入类型决定的，所以一定会用到泛型</p>
]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>vim快捷键</title>
    <url>/2022/03/21/vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>vim快捷键总结</p>
<span id="more"></span>

<p><a href='https://coolshell.cn/articles/5426.html'>简明Vim练级攻略</a><br><a href='https://muyuuuu.github.io/2021/08/28/vim-learn/'>关于六天掌握 Vim 这件事</a><br><a href='https://chengjingchao.com/2020/06/13/VS-Code-%E4%B8%8E-Vim'>Vscode和Vim</a></p>
<h2 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h2><p>dd 删除一行<br>i 切换insert模式<br>x 删除一个字符<br>u 撤销删除<br>:wq 保存+退出<br>hljk 左右上下<br>:help [commend] 显示相关命令帮助<br>个人配置后：更快速的移动 normal 模式下 J &#x3D;&gt; 5j, K &#x3D;&gt; 5k</p>
<h2 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h2><p>a 在光标后插入<br>o 在当前行后面插入新行<br>O 当前行前面插入新行<br>cw 替换从光标所在位置后到一个单词结尾的字符</p>
<p>p 粘贴剪切板<br>yy 复制当前行</p>
<p>:e [path] 打开一个文件<br>:q! 退出不保存</p>
<p>0 光标移动到行首<br>$ 光标移动到行尾</p>
<p>v进入visual模式，光标移动进行选中，y进行复制，p进行粘贴</p>
<h2 id="day-3"><a href="#day-3" class="headerlink" title="day 3"></a>day 3</h2><p>. 重复上一次命令<br>2dd 删除2行<br>10p 粘贴文本10次</p>
<p>gg 移动到文件开头<br>G 移动到文件末尾<br>NG 移动到第N行<br>gd 跳转到定义<br>gh 相当于鼠标悬停到光标所在位置</p>
<p>ctrl+f 向下翻页<br>ctrl+b 向上翻页<br>ctrl+e 逐行向下翻页<br>ctrl+y 逐行向上翻页</p>
<p>b 上一个单词开头<br>e 当前单词结尾</p>
<p>% 匹配括号移动<br>* 匹配光标当前单词，移动光标到下一个单词</p>
<p><code>0y$</code> 从行头复制到行尾<br>ye 从当前位置拷贝到本单词最后一个字符</p>
<p>gU 变大写<br>gu 变小写</p>
<h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p>ye 复制光标后的单词<br>yl 复制光标后的字符<br>yh 复制光标前的字符</p>
<p>dd 删除整行<br>dw 删除当前单词</p>
<h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><p>jj 个人配置的esc键<br>xx 个人配置的：再行末添加</p>
<p>zz 当前行放在页面中间<br>H(head) 移动到屏幕顶部<br>M(middle) 移动到屏幕中间</p>
<h2 id="Vimium"><a href="#Vimium" class="headerlink" title="Vimium"></a>Vimium</h2><p><a href="https://zhuanlan.zhihu.com/p/64533566">https://zhuanlan.zhihu.com/p/64533566</a><br><a href="https://linuxfstab.com/2020/03/22/vimium/">https://linuxfstab.com/2020/03/22/vimium/</a><br>T 搜索标签页<br>f+[] 打开网页<br>O 搜索<br>H 返回上一页</p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Git命令</title>
    <url>/2022/03/13/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>记录一些常用的git命令方便查阅</p>
<span id="more"></span>

<p>git add .<br>git commit -m ‘[文字]’<br>git push 从本地推送代码到远程<br>git pull 从远程拉取代码到本地<br>git checkout [分支名] 切换到某个分支<br>git branch 查看当前分支<br>git merge [分支名] 合并分支<br>git stash：存储临时代码。<br>git reset –soft：软回溯，回退 commit 的同时保留修改内容。<br>git cherry-pick：复制 commit。<br>git revert：撤销 commit 的修改内容。<br>git reflog：记录了 commit 的历史操作。</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建Hexo+GitHubPages博客</title>
    <url>/2022/03/07/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo-GitHubPages%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>无需购买域名、配置服务器，只需要一个github账号即可搭建个人博客</p>
<span id="more"></span>

<h2 id="安装git和Node"><a href="#安装git和Node" class="headerlink" title="安装git和Node"></a>安装git和Node</h2><h2 id="安装并启动Hexo"><a href="#安装并启动Hexo" class="headerlink" title="安装并启动Hexo"></a>安装并启动Hexo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v </span><br><span class="line">hexo init mona_blog</span><br><span class="line">cd mona_blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<h2 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new first_blog</span><br><span class="line">hexo generate 简写　hexo g</span><br><span class="line">hexo server　简写 hexo s</span><br><span class="line">hexo deploy　简写 hexo d</span><br></pre></td></tr></table></figure>

<h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><ol>
<li>修改_config.yml文件：修改并添加type repo branch的值，示例如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/monaaaaaa2544/monaaaaaa2544.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装hexo-deployer-git插件，运行<code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>重新运行<code>hexo clean</code> &amp;&amp; <code>hexo g</code> &amp;&amp;<code>hexo d</code></p>
</li>
</ol>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ol>
<li><p>安装NextT主题 <code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>这是将Next主题下载到blog目录的themes主题下的next文件夹中。</p>
</li>
<li><p>打开站点的_config.yml配置文件，修改主题为next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开themes下的_config.yml文件，找到Scheme Settings，Next有4种主题可选，选一个取消注释即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载插件<code>npm i hexo-renderer-swig</code><br>这里由于Hexo升级的问题，必须下载swig渲染插件</p>
</li>
<li><p>重新运行<code>hexo clean</code> &amp;&amp; <code>hexo g</code> &amp;&amp;<code>hexo d</code></p>
</li>
</ol>
<h2 id="Hexo-命令总结"><a href="#Hexo-命令总结" class="headerlink" title="Hexo 命令总结"></a>Hexo 命令总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d </span><br><span class="line">hexo s  </span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>

<h2 id="NexT配置"><a href="#NexT配置" class="headerlink" title="NexT配置"></a>NexT配置</h2><ol>
<li>浏览页面显示当前浏览进度<br>找到_config.yml中的关键字scrollpercent, 设置为true</li>
<li>本地搜索功能</li>
</ol>
<ul>
<li>安装插件<code>npm install hexo-generator-searchdb --save</code></li>
<li>添加如下配置到_config.yml中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure></li>
<li>修改如下参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="博客添加音乐"><a href="#博客添加音乐" class="headerlink" title="博客添加音乐"></a>博客添加音乐</h2><p>使用MeingJS<br>具体可查阅：<a href='https://blog.csdn.net/weixin_43471926/article/details/109798928'> Hexo-Fluid主题添加音乐页面</a><br><a href='https://mackvord.github.io/aplayer-dplayer/547187035.html'>Aplayer &amp; Dplayer 嵌入音频和视频</a></p>
<h2 id="Hexo博客Next主题添加统计文章阅读量、评论等功能"><a href="#Hexo博客Next主题添加统计文章阅读量、评论等功能" class="headerlink" title="Hexo博客Next主题添加统计文章阅读量、评论等功能"></a>Hexo博客Next主题添加统计文章阅读量、评论等功能</h2><p><a href="https://blog.csdn.net/qq_32566003/article/details/116564864">如何为next主题添加不蒜子统计</a><br><a href='https://blog.csdn.net/Time888/article/details/74203939?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3'>为NexT主题添加文章阅读量统计功能</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href='https://zhuanlan.zhihu.com/p/26625249'>GitHub+Hexo 搭建个人网站详细教程</a><br><a href='https://mackvord.github.io/aplayer-dplayer/547187035.html'>Aplayer &amp; Dplayer 嵌入音频和视频</a><br><a href='https://blog.csdn.net/as480133937/article/details/100138838'>Hexo-Next 主题博客个性化配置超详细，超全面(两万字)</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>优质资源</title>
    <url>/2022/03/17/%E6%94%B6%E9%9B%86%E4%BC%98%E7%A7%80%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>收集优秀的博客、公众号等，便于时常阅读</p>
<span id="more"></span>

<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><a href='https://muyiy.cn/blog/'>木易杨前端进阶</a><br><a href='https://staging-cn.vuejs.org/guide/typescript/composition-api.html'>更清楚的Vue3文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>前端CSS</title>
    <url>/2022/04/30/%E5%89%8D%E7%AB%AFCSS/</url>
    <content><![CDATA[<p>CSS相关知识</p>
<span id="more"></span>


<h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><p>position: absolute|relative|fixed|sticky<br>z-index:0|1 该属性可以解决重叠元素问题</p>
<p><a href='https://www.ruanyifeng.com/blog/2019/11/css-position.html'>CSS 定位详解</a><br><a href='https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning'>CSS 定位 MDN</a><br><a href='https://jsbin.com/jafeqarepo/edit?html,css,output'>demo</a></p>
]]></content>
  </entry>
  <entry>
    <title>前端JS</title>
    <url>/2022/04/30/%E5%89%8D%E7%AB%AFJS/</url>
    <content><![CDATA[<p>JS知识点</p>
<span id="more"></span>


<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p><a href='https://www.bilibili.com/video/BV1864y117PQ?p=2&share_medium=iphone&share_plat=ios&share_session_id=95D86177-AF23-4C6E-A45B-F1EFA4D0D48C&share_source=WEIXIN&share_tag=s_i&timestamp=1651559870&unique_k=01mzLbf'>方方讲Event Loop</a><br><a href='https://www.bilibili.com/video/BV1kf4y1U7Ln?p=1&share_medium=iphone&share_plat=ios&share_session_id=BA787B04-4CED-4459-B2F3-F976759F0609&share_source=WEIXIN&share_tag=s_i&timestamp=1651560378&unique_k=uEn3leu'>2分钟了解 JavaScript Event Loop</a><br><a href='https://juejin.cn/post/6844904021296316429'>EventLoop面试经典</a></p>
<p>nextTick 当前任务执行完后立即执行<br>resolve() 看见它就会推迟2个微任务<br>Node和浏览器都会设置一个超限任务数量，比如当微任务做了100个时就不再继续做微任务了，转而执行宏任务<br>Node和JS中的Event Loop不一样</p>
<h6 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h6><p>setTimeout setInterval requestAnimationFrame</p>
<h6 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h6><p>Promises queueMicrotask MutationObserver</p>
<h6 id="Node的六个阶段"><a href="#Node的六个阶段" class="headerlink" title="Node的六个阶段"></a>Node的六个阶段</h6><p>【1 timers】            setTimeout setInterval 【nextTick】<br>【2 I&#x2F;O callbacks】<br>【3 idle,prepare】<br>【4 poll】              轮询 文件【nextTick】<br>【5 check】             setImmediate【nextTick】<br>【6 close callbacks】<br>nextTick、Promise.then()在每一个阶段的末尾立即执行</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h6 id="Ajax介绍"><a href="#Ajax介绍" class="headerlink" title="Ajax介绍"></a>Ajax介绍</h6><p>可参考：<a href='https://www.zhihu.com/question/20874229'>你怎么用最通俗的话解释AJAX是什么东西</a></p>
<p>直白地说，就是没用AJAX的网页，你点一个按钮就要刷新一下页面，尽管新页面上只有一行字和当前页面不一样，但你还是要无聊地等待页面刷新。用了AJAX之后，你点击，然后页面上的一行字就变化了，页面本身不用刷。AJAX只是一种技术，不是某种具体的东西。不同的浏览器有自己实现AJAX的组件。</p>
<p>AJAX&#x3D;异步传输+JS+XML（现在其实是用JSON数据格式代替XML）</p>
<p>使用Ajax技术不必刷新整个页面，只需对页面的局部进行更新，可以节省网络带宽，提高页面的加载速度，从而缩短用户等待时间，改善用户体验</p>
<h6 id="Ajax实现"><a href="#Ajax实现" class="headerlink" title="Ajax实现"></a>Ajax实现</h6><p>可参考：<br><a href='https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400'>廖雪峰的AjAX</a><br><a href='https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started'>MDN AJAX</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">success</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.<span class="property">value</span> = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">code</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.<span class="property">value</span> = <span class="string">&#x27;Error code: &#x27;</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(request.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fail</span>(request.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="实现跨域的几种方法"><a href="#实现跨域的几种方法" class="headerlink" title="实现跨域的几种方法"></a>实现跨域的几种方法</h6><p>可以参考：<a href='https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400'>廖雪峰的AjAX</a></p>
<ol>
<li>用flash插件发送HTTP请求</li>
<li>再同源域名下开一个代理服务器来转发，代理服务器把结果返回</li>
<li>JSONP。这种方法利用了浏览器允许跨域引用JavaScript资源</li>
<li>CORS。目标域设置Access-Control-Allow-Origin</li>
</ol>
<h6 id="前端发展史"><a href="#前端发展史" class="headerlink" title="前端发展史"></a>前端发展史</h6><p>参考：<a href="https://time.geekbang.org/column/article/427660">https://time.geekbang.org/column/article/427660</a></p>
<ol>
<li>静态页面（HMTL+CSS+JavaScript）</li>
<li>动态网页（MVC写模板代码（JSP+Smarty））（但是这样做的坏处是每次更新数据都会刷新一遍页面）</li>
<li>Ajax。这个技术可以异步的获取数据并且可以不刷新整个页面</li>
<li>JQuery开发模式（前端代码内嵌在后端（JQuery+Bootstrap）、DOM操作、统一了写法解决了兼容性）</li>
<li>MVVM模式（Angular、React、Vue）（数据驱动页面）</li>
</ol>
<h6 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h6><p>参考：<a href="https://xiedaimala.com/tasks/c08da570-56a5-4afc-b5e9-b9a48f005d23/video_tutorials/f3df3400-0749-4989-be33-278d21b5438c">https://xiedaimala.com/tasks/c08da570-56a5-4afc-b5e9-b9a48f005d23/video_tutorials/f3df3400-0749-4989-be33-278d21b5438c</a></p>
<p>首先虚拟DOM好于真实DOM，因为真实dom在渲染过程中会造成dom的重排和重绘，虚拟DOM只会渲染局部，性能更好</p>
<p>React中的虚拟DOM<br>diff计算<br>Vue2.0中的虚拟DOM<br>一是通过绑定Watcher（控制组件间变化），二是通过虚拟DOM（控制组件内部数据变化）</p>
<h6 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed watch"></a>computed watch</h6><h6 id="Vue2到Vue3做了什么"><a href="#Vue2到Vue3做了什么" class="headerlink" title="Vue2到Vue3做了什么"></a>Vue2到Vue3做了什么</h6><p>参考：<a href="https://time.geekbang.org/column/article/428904">https://time.geekbang.org/column/article/428904</a></p>
<ol>
<li>Vue2<br>响应式驱动、内置虚拟DOM、组件化、浏览器开发<br>Vue2缺陷：</li>
</ol>
<ul>
<li>有跨端问题。因为Vue 2 内部运行时，是直接执行浏览器 API 的，跨端时就需要把浏览器API换成客户端或者小程序的。</li>
<li>Option API在较多组件时，代码不易维护。因为对于 Option API 来说，所有的 methods、computed 都在一个对象里配置，新增或者修改一个功能，就需要不停地在 data，methods 里跳转写代码，我称之为上下反复横跳。</li>
</ul>
<ol start="2">
<li>Vue3<br>7个新特性：响应式系统、Composition API、Vite、自定义渲染器、RFC机制、TypeScript重构</li>
</ol>
<ul>
<li>新的 RFC 机制也让我们所有人都可以参与 Vue 新语法的讨论。</li>
<li>工程化工具 Vite 带来了更丝滑的调试体验。</li>
<li>Composition API 组合语法带来了更好的组织代码的形式</li>
<li>全新的响应式系统基于 Proxy，也可以独立使用</li>
<li>Vue 3 内置了新的 Fragment、Teleport 和 Suspense 等组件</li>
<li>对于 Vue 的二次开发来说，自定义渲染器让我们开发跨端应用时更加得心应手</li>
<li>对于 Vue 的源码维护者，全部的模块使用 TypeScript 重构，能够带来更好的可维护性。</li>
</ul>
<p><a href='https://static001.geekbang.org/resource/image/cc/d0/cc47460b1f9441d843bff6d37777a8d0.jpg?wh=3059x1664'>Vue3新特性</a></p>
<h6 id="Object-defineProperty-和-Proxy"><a href="#Object-defineProperty-和-Proxy" class="headerlink" title="Object.defineProperty() 和 Proxy"></a>Object.defineProperty() 和 Proxy</h6><p>参考：<a href="https://vue3js.cn/es6/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8proxy%E9%87%8D%E6%9E%84">https://vue3js.cn/es6/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8proxy%E9%87%8D%E6%9E%84</a></p>
<p>Vue2的响应式机制是基于Object.defineProperty()实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;title&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这两者的区别呢？<br>defineProperty 本身，是对对象上的属性做操作，而非对象本身，新增属性无法通过 get set 更新。<br>Proxy 劫持的是整个对象，而不想defineProperty那样是对象上的属性，所以新增属性也能get set</p>
<h6 id="Options-API-和-Composition-API"><a href="#Options-API-和-Composition-API" class="headerlink" title="Options API 和 Composition API"></a>Options API 和 Composition API</h6><p>参考：<a href="https://time.geekbang.org/column/article/428904">https://time.geekbang.org/column/article/428904</a></p>
<p>Options API 的写法也有几个很严重的问题：</p>
<ul>
<li>由于所有数据都挂载在 this 之上，因而 Options API 的写法对 TypeScript 的类型推导很不友好，并且这样也不好做 Tree-shaking 清理代码。</li>
<li>新增功能基本都得修改 data、method 等配置，并且代码上 300 行之后，会经常上下反复横跳，开发很痛苦。</li>
<li>代码不好复用，Vue 2 的组件很难抽离通用逻辑，只能使用 mixin，还会带来命名冲突的问题。</li>
</ul>
<p>使用 Composition API 好处：</p>
<ul>
<li>所有 API 都是 import 引入的，用到的功能都 import 进来，对 Tree-shaking 很友好，我的例子里没用到功能，打包的时候会被清理掉 ，减小包的大小。</li>
<li>不再上下反复横跳，我们可以把一个功能模块的 methods、data 都放在一起书写，维护更轻松。</li>
<li>代码方便复用，可以把一个功能所有的 methods、data 封装在一个独立的函数里，复用代码非常容易。</li>
<li>Composotion API 新增的 return 等语句，在实际项目中使用</li>
</ul>
<p><a href='https://static001.geekbang.org/resource/image/a0/5f/a0010538b40e48fc5fc68b0eed2b025f.jpg?wh=3220x2046'>Options API 和 Composition API代码结构对比</a></p>
<h6 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h6><h6 id="Vue3中使用TS"><a href="#Vue3中使用TS" class="headerlink" title="Vue3中使用TS"></a>Vue3中使用TS</h6><p>参考：<a href="https://time.geekbang.org/column/article/445880">https://time.geekbang.org/column/article/445880</a></p>
<h6 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h6><p>参考：<a href="https://time.geekbang.org/column/article/431955">https://time.geekbang.org/column/article/431955</a></p>
<p>Composition API 的逻辑来拆分代码，把一个功能相关的数据和方法都维护在一起。</p>
<h6 id="Vue3生命周期钩子"><a href="#Vue3生命周期钩子" class="headerlink" title="Vue3生命周期钩子"></a>Vue3生命周期钩子</h6><h6 id="HTTP-x2F-2协议相对于HTTP-x2F-1-1在性能上有了很大的提升，主要具有以下新特性"><a href="#HTTP-x2F-2协议相对于HTTP-x2F-1-1在性能上有了很大的提升，主要具有以下新特性" class="headerlink" title="HTTP&#x2F;2协议相对于HTTP&#x2F;1.1在性能上有了很大的提升，主要具有以下新特性"></a>HTTP&#x2F;2协议相对于HTTP&#x2F;1.1在性能上有了很大的提升，主要具有以下新特性</h6><p>二进制分帧<br>请求与响应复用<br>服务端推送<br>头部压缩</p>
]]></content>
  </entry>
  <entry>
    <title>深度学习中pytorch操作</title>
    <url>/2022/05/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADpytorch%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>pytorch 数据处理</p>
<span id="more"></span>

<h3 id="创建空的tensor"><a href="#创建空的tensor" class="headerlink" title="创建空的tensor"></a>创建空的tensor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logits_cpu = torch.tensor([])</span><br></pre></td></tr></table></figure>

<h3 id="保存两列tensor到csv文件"><a href="#保存两列tensor到csv文件" class="headerlink" title="保存两列tensor到csv文件"></a>保存两列tensor到csv文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayStruct = numpy.transpose(</span><br><span class="line">[targets_cpu.cpu().numpy(), logits_cpu[:, 0].numpy(), logits_cpu[:, 1].numpy()])</span><br><span class="line"></span><br><span class="line">with open(output, &#x27;w&#x27;) as f:</span><br><span class="line">	numpy.savetxt(f, ArrayStruct, header=&#x27;targets, logits0, logits1&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="torch-where-y-pred-gt-0-5-1-0"><a href="#torch-where-y-pred-gt-0-5-1-0" class="headerlink" title="torch.where(y_pred&gt;0.5, 1, 0)"></a>torch.where(y_pred&gt;0.5, 1, 0)</h3><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/dc18d7dc93cff74a.png" alt="image-20220523212137021"></p>
<h3 id="natural-y-pred-x3D-x3D-y-sum-dim-x3D-0"><a href="#natural-y-pred-x3D-x3D-y-sum-dim-x3D-0" class="headerlink" title="(natural_y_pred &#x3D;&#x3D; y).sum(dim&#x3D;0)"></a>(natural_y_pred &#x3D;&#x3D; y).sum(dim&#x3D;0)</h3><p><img src="https://s3.bmp.ovh/imgs/2022/06/16/c6d2b69659a9311a.png" alt="image-20220523221816231"></p>
]]></content>
  </entry>
  <entry>
    <title>JS刷题语法</title>
    <url>/2022/06/27/JS%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>



<h2 id="JS-语法"><a href="#JS-语法" class="headerlink" title="JS 语法"></a>JS 语法</h2><h4 id="JavaScript字符与acsii值互转"><a href="#JavaScript字符与acsii值互转" class="headerlink" title="JavaScript字符与acsii值互转"></a>JavaScript字符与acsii值互转</h4><p>“a”.charCodeAt()</p>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p>count+&#x3D;n&amp;1<br>n&#x3D;n&gt;&gt;&gt;1</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>let dp&#x3D;new Array(n).fill(0) 新建一维数组<br>let dp&#x3D;Array.from(new Array(n), ()&#x3D;&gt;new Array(2).fill(0))   新建二维数组</p>
<p>arr.length  数组长度<br>arr.push(1)<br>arr.pop(1)<br>arr.shift(2)    弹出第一个元素<br>arr.unshift()   添加元素到开头<br>arr.indexOf(3)&#x3D;&#x3D;&#x3D;-1     不存在<br>stack[stack.length-1]   栈顶元素<br>arr.push({<br>    name:parseInt(line[0]),<br>    score:parseInt(line[1]),<br>    index:i<br>})                      数组对象<br>arr.reverse()<br>arr.splice(2, 6)    删除从2开始的6个元素<br>arr.splice(位置，删除元素的数量，元素）        指定位置插入元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;four&quot;</span>];</span><br><span class="line"><span class="comment">// splice(position, numberOfItemsToRemove, item)</span></span><br><span class="line"><span class="comment">// 拼接函数(索引位置, 要删除元素的数量, 元素)</span></span><br><span class="line">array.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line"> </span><br><span class="line">array;  <span class="comment">// 现在数组是这个样子 [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br></pre></td></tr></table></figure>





<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>String(3)           字符串转换<br>str.indexOf(“fasd”)<br>s.includes(str)     字符串查找子串<br>s.substring(4,6)    截取字符串<br>slice()函数     截取字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">&#x27;ant&#x27;</span>, <span class="string">&#x27;bison&#x27;</span>, <span class="string">&#x27;camel&#x27;</span>, <span class="string">&#x27;duck&#x27;</span>, <span class="string">&#x27;elephant&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(animals.<span class="title function_">slice</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="res-x3D-Infinity"><a href="#res-x3D-Infinity" class="headerlink" title="res&#x3D;-Infinity"></a>res&#x3D;-Infinity</h4><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">从小到大排序</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="获取数组最后一个元素"><a href="#获取数组最后一个元素" class="headerlink" title="获取数组最后一个元素"></a>获取数组最后一个元素</h4><ol>
<li>arr.slice(-1)</li>
<li>arr[arr.length-1]</li>
</ol>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch(s){</p>
<p>​    case “A”:</p>
<p>​        break;</p>
<p>​    case “B”:</p>
<p>​        break;</p>
<p>}</p>
<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p> reg&#x3D;&#x2F;^([ADWS])([\d]+$)&#x2F;</p>
<h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><p>Number.MAX_VALUE</p>
<h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><p>Number.MIN_VALUE<br>Infinity</p>
<h4 id="定义类的两种方法"><a href="#定义类的两种方法" class="headerlink" title="定义类的两种方法:"></a>定义类的两种方法:</h4><p>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Cat</span>=<span class="keyword">function</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat1=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>)</span><br><span class="line">cat1.<span class="title function_">sayHi</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>class</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat1=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;lxy&quot;</span>, <span class="number">23</span>)</span><br><span class="line">cat1.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>arr1.push(…arr2)    连接两个数组<br>Math.max(…arr)        求数组中数值最大值<br>const a2 &#x3D; […a1]        复制数组<br>[…arr1, …arr2, …arr3]    合并数组<br>[…new Set(arr)]                数组去重</p>
<h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><p>map()、reduce()                返回处理后的新数组<br>Object.assign()、slice()、concat()、扩展运算符                    浅拷贝<br>JSON.stringify()、JSON.parse()                深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr))</span><br></pre></td></tr></table></figure>
<p>let union&#x3D;new Set([…a, …b])                    实现并集<br>let intersect&#x3D;[…a].filter(v&#x3D;&gt;b.has(a))        实现交集<br>let diff&#x3D;[…a].filter(v&#x3D;&gt;!b.has(a))                    实现差集<br>String()、arr.toString()            转换为字符串</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h4><p>let s&#x3D;new Set()     集合里没有重复元素<br>s.add(2)<br>s.delete(value)<br>s.has(value)<br>s.size<br>s.clear()<br>forEach</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h4><p>let map&#x3D;new Map()<br>map.get(key)<br>map.set(key, value)<br>map.has(key)<br>map.delete(key)<br>map.size<br>forEach</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line">      <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">      </span><br><span class="line">      map.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>) </span><br><span class="line">      map.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//2</span></span><br><span class="line">      map.<span class="title function_">has</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">//false</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> item <span class="keyword">of</span> <span class="attr">map</span>:</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">      </span><br><span class="line">      map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, k</span>)=&gt;</span>&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(v, k)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Object"><a href="#Object" class="headerlink" title="Object:"></a>Object:</h4><p>let obj&#x3D;new Object()<br>obj.a&#x3D;’adf’</p>
<h4 id="sdfa"><a href="#sdfa" class="headerlink" title="sdfa"></a>sdfa</h4><p>[true, false, true].every(item&#x3D;&gt;item)    &#x2F;&#x2F;false</p>
]]></content>
  </entry>
  <entry>
    <title>Python刷题语法</title>
    <url>/2022/06/27/Python%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Python-语法"><a href="#Python-语法" class="headerlink" title="Python 语法"></a>Python 语法</h2><h4 id="python常用模块"><a href="#python常用模块" class="headerlink" title="python常用模块"></a>python常用模块</h4><p><a href='https://blog.csdn.net/Shenpibaipao/article/details/105873407'>[Python][刷题常用模块]用Python刷题，这一篇就够了</a><br><a href="https://blog.nowcoder.net/n/b4d00041304748b1a522275243fd87e6">https://blog.nowcoder.net/n/b4d00041304748b1a522275243fd87e6</a><br><a href="https://xdren69.github.io/2021/03/31/leetcode-python/">https://xdren69.github.io/2021/03/31/leetcode-python/</a><br><a href="http://www-quic.zhihu.com/question/392867890">http://www-quic.zhihu.com/question/392867890</a><br><a href='https://codingdict.com/article/4843'>CodingDict</a></p>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>int(a, 2) a数值转换成2进制</p>
<p>bin(a)[2:] a数值转换成2进制</p>
<h4 id="字符串转Ascii"><a href="#字符串转Ascii" class="headerlink" title="字符串转Ascii"></a>字符串转Ascii</h4><p>ord(‘a’)    字符串转asc</p>
<p>chr(98)    asc转字符串</p>
<ol>
<li><p>max(a, b)</p>
</li>
<li><p>队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; import queue </span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt; q=queue.Queue(5)</span><br><span class="line">&gt;</span><br><span class="line">&gt; q.put(123)</span><br><span class="line">&gt;</span><br><span class="line">&gt; q.get()</span><br></pre></td></tr></table></figure></li>
<li><p>优先级队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;import queue</span><br><span class="line">&gt;</span><br><span class="line">&gt;q=queue.PriorityQueue()</span><br><span class="line">&gt;</span><br><span class="line">&gt;同上put get</span><br><span class="line">&gt;</span><br><span class="line">&gt;结构相当于一个堆</span><br></pre></td></tr></table></figure></li>
<li><p>栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt;from collections import deque</span><br><span class="line">&gt;</span><br><span class="line">&gt;s=deque()</span><br><span class="line">&gt;</span><br><span class="line">&gt;s.append(1)</span><br><span class="line">&gt;</span><br><span class="line">&gt;s.pop()</span><br><span class="line">&gt;</span><br><span class="line">&gt;或者用LifoQueue</span><br><span class="line">&gt;</span><br><span class="line">&gt;from queue</span><br><span class="line">&gt;</span><br><span class="line">&gt;s=queue.LifoQueue()</span><br><span class="line">&gt;</span><br><span class="line">&gt;s.put(1)</span><br><span class="line">&gt;</span><br><span class="line">&gt;s.get()</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候用python报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;sum&#x27; referenced before assignment</span><br><span class="line">    sum+=root.val</span><br><span class="line">Line 20 in traverse (Solution.py)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">Line 18 in traverse (Solution.py)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">Line 18 in traverse (Solution.py)</span><br><span class="line">    traverse(root.right)</span><br><span class="line">Line 18 in traverse (Solution.py)</span><br><span class="line">    traverse(root)</span><br><span class="line">Line 27 in convertBST (Solution.py)</span><br><span class="line">    ret = Solution().convertBST(param_1)</span><br><span class="line">Line 49 in _driver (Solution.py)</span><br><span class="line">    _driver()</span><br><span class="line">Line 60 in &lt;module&gt; (Solution.py)</span><br><span class="line"></span><br><span class="line">解决方法：nonlocal 定义非定义域所在变量</span><br></pre></td></tr></table></figure>
</li>
<li><p>python 创建二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=[[<span class="number">0</span>]*<span class="number">3</span>]*<span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>python 小顶堆</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网：https://docs.python.org/zh-cn/3/library/heapq.html</span><br><span class="line">from heapq import *</span><br><span class="line"></span><br><span class="line">heap=[]</span><br><span class="line">heappush(heap, 1)</span><br><span class="line">heappop(heap) # 0</span><br><span class="line">print(len(heap)) # 堆大小 </span><br><span class="line">print(heap[0]) # 栈顶最小元素</span><br><span class="line">//将列表转换为堆</span><br><span class="line">heap2 = [5, 8, 0, 4, 6, 7]</span><br><span class="line">heapify(heap2)</span><br><span class="line">print(heap2)   #[0, 4, 5, 8, 6, 7]</span><br><span class="line"></span><br><span class="line">//前n个最大的或前n个最小的元素</span><br><span class="line">lst = [5, 8, 0, 4, 6, 7]</span><br><span class="line">print(nsmallest(3, lst))</span><br><span class="line">print(nlargest(3, lst))</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>python 字典（哈希表）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict=&#123;&#125;</span><br><span class="line"></span><br><span class="line">dict[&#x27;Age&#x27;]=18</span><br></pre></td></tr></table></figure>
</li>
<li><p>python 数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr=[]</span><br><span class="line"></span><br><span class="line">arr.push(3)</span><br><span class="line">arr.pop()</span><br><span class="line">arr.pop(0) //删除第一个元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>python 字符串</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&#x27;sadfasdf,asdfa&#x27;</span><br><span class="line"></span><br><span class="line">s.split(&#x27;,&#x27;)</span><br></pre></td></tr></table></figure>
<ol start="11">
<li><p>python 设定最大值最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys.maxsize python3中设置最大值</span><br><span class="line">-sys.maxsize-1 python3中设置最小值</span><br></pre></td></tr></table></figure></li>
<li><p>输入字符转换为ASCII码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ord</span>(ch)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入ASCII码转换为字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chr(ch)</span><br></pre></td></tr></table></figure>
</li>
<li><p>str.find(s, beg, end)<br><a href="https://www.runoob.com/python/att-string-find.html">https://www.runoob.com/python/att-string-find.html</a></p>
</li>
<li><p>定义二维数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp = [[0] * (n + 1) for _ in range(m + 1)] #尽量用这个</span><br><span class="line">dp2=[[0]*(n+1)]*(m+1) #这个有时会导致出错</span><br><span class="line">print(dp==dp2) # True</span><br></pre></td></tr></table></figure></li>
<li><p>遍历哈希表</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for k in h.keys():</span><br><span class="line">            print(k)</span><br></pre></td></tr></table></figure>

<ol start="17">
<li><p>遍历枚举类型数组</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i,num in enumerate(nums):</span><br><span class="line">    print(i,num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>abs()</p>
</li>
<li><p>split()</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s=&#x27;sdf,asdfa&#x27;</span><br><span class="line"></span><br><span class="line">arr=s.split(&#x27;,&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="20">
<li>strip()</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.strip() # 去掉空格</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="21">
<li><p>range(start, stop, step)</p>
</li>
<li><p>数组添加可以不用append,直接+</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2]+[3]=[2,3]</span><br></pre></td></tr></table></figure>

<ol start="23">
<li>左移乘2、右移除2</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;1 </span><br><span class="line">&gt;&gt;1</span><br></pre></td></tr></table></figure>

<ol start="24">
<li>&amp; 和 and     |和or是不同的</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;   二进制与运算</span><br><span class="line">and 与运算</span><br><span class="line">|   二进制或运算</span><br><span class="line">or  或运算</span><br></pre></td></tr></table></figure>

<ol start="25">
<li>set()函数</li>
</ol>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">visited=<span class="built_in">set</span>()</span><br><span class="line">visited.add(<span class="number">3</span>)</span><br><span class="line">visited.add(<span class="number">3</span>) <span class="comment">#重复元素会被删除</span></span><br></pre></td></tr></table></figure>
<ol start="26">
<li>双端队列 deque()   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">q=collections.deque()</span><br><span class="line">q.push(<span class="number">3</span>)</span><br><span class="line">q.push(<span class="number">4</span>)</span><br><span class="line">q.popleft()</span><br><span class="line">q.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>import queue</li>
</ol>
<p>deque&#x3D;queue.deque()<br>queue&#x3D;queue.Queue()</p>
<ol start="28">
<li>join拼接字符串</li>
</ol>
<p>res&#x3D;[‘sdf’, ‘sdf’, ‘d’]<br>str&#x3D;’  ‘.join(res) # ‘sdfsdfd’</p>
<ol start="29">
<li>arr.sort()</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>发布订阅模式</title>
    <url>/2022/07/23/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式之发布订阅模式</p>
<span id="more"></span>
<p>参考链接：方方视频，或者<a href="http://static.kancloud.cn/wengwang/read_1/436079">http://static.kancloud.cn/wengwang/read_1/436079</a></p>
<p>简而言之就是订阅（添加函数），发布（调用函数）的过程<br>所有的DOM元素绑定的事件函数，就是发布订阅模式，<code>addEventListener(&#39;click&#39;, function()&#123;&#125;)</code> 就是一种这种模式的实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eventBus=&#123;</span><br><span class="line">    <span class="attr">arrays</span>:&#123;</span><br><span class="line">            <span class="attr">click</span>:[],</span><br><span class="line">            <span class="attr">touch</span>:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">type, fn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arrays</span>[type]=<span class="variable language_">this</span>.<span class="property">arrays</span>[type] || []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">arrays</span>[type].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">type, str</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a=<span class="variable language_">this</span>.<span class="property">arrays</span>[type]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;a.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">const</span> fn=a[i]</span><br><span class="line">            <span class="title function_">fn</span>(str) <span class="comment">//调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;click:&quot;</span>, data)&#125;) <span class="comment">//订阅</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&quot;touch&quot;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;touch:&quot;</span>, data)&#125;) <span class="comment">//订阅</span></span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&quot;click&quot;</span>, <span class="string">&quot;me&quot;</span>)<span class="comment">//发布</span></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&quot;touch&quot;</span>, <span class="string">&quot;you&quot;</span>)<span class="comment">//发布</span></span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;you&quot;</span>)<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>前端中的异步请求</title>
    <url>/2022/07/24/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>异步</p>
<span id="more"></span>

<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>参考：<a href="https://juejin.cn/post/7015842918799769637">https://juejin.cn/post/7015842918799769637</a></p>
<p>实现AJAX请求的步骤：</p>
<ol>
<li>创建 XMLHttpRequest 对象</li>
<li>设置状态监听函数</li>
<li>规定请求的类型、URL、请求体</li>
<li>将请求发送到服务器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Ajax</span>(<span class="params">type, url, body</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line">        xhr.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">readyState</span>===<span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span>===<span class="number">200</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求成功,返回的结果是：&quot;</span>, xhr.<span class="property">responseText</span>)</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(xhr.<span class="property">responseText</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">open</span>(type, url)<span class="comment">//与服务器建立连接</span></span><br><span class="line">        xhr.<span class="title function_">send</span>(body) <span class="comment">//发送请求，并带上数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Ajax</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.baidu.com&quot;</span>, <span class="literal">null</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// AJAX成功，拿到响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Ajax缺点：</p>
<ul>
<li>基于事件的异步模型不友好</li>
<li>基于MVC编程，不符合前端MVVM的浪潮</li>
<li>Ajax基于原生XHR开发，架构不清晰</li>
</ul>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>参考：<a href="https://blog.csdn.net/weixin_43443341/article/details/120075459">https://blog.csdn.net/weixin_43443341/article/details/120075459</a></p>
<p>Axios是基于Promise封装的</p>
<p>axios可以设置请求拦截器、响应拦截器，请求拦截器可以在请求发送之前判断是否存在合理的token，从而能验证你的登录情况，下面时Axios拦截器的使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么, 比如验证token之类的</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(拦截器是什么意思呢？其实就是在我们发送一个请求的时候会先执行请求拦截器的代码，然后再真正地执行我们发送的请求，这个过程会对config，也就是我们发送请求时传送的参数进行一些操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而当接收响应的时候，会先执行响应拦截器的代码，然后再把响应的数据返回来，这个过程会对response，也就是响应的数据进行一系列操作。)</span></span><br></pre></td></tr></table></figure>

<p>axios可以进一步封装get post请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">      <span class="attr">baseURL</span>: ishttps ? process.<span class="property">env</span>.<span class="property">VUE_APP_API_BASEURL_HTTPS</span> : process.<span class="property">env</span>.<span class="property">VUE_APP_API_BASEURL_HTTP</span>,</span><br><span class="line">      <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装get请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">url, params</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    instance</span><br><span class="line">      .<span class="title function_">get</span>(url, &#123;</span><br><span class="line">        <span class="attr">params</span>: params,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res.<span class="property">data</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err.<span class="property">data</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Axios:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//添加拦截器对象、</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">interceptors</span>=&#123;</span><br><span class="line">            <span class="attr">request</span>:<span class="keyword">new</span> <span class="title class_">InterceptorsManage</span> <span class="comment">//一个用来处理请求</span></span><br><span class="line">            <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorsManage</span> <span class="comment">//一个用来处理响应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//带有拦截器的请求方法</span></span><br><span class="line">    <span class="title function_">request</span>(<span class="params">config</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> chain=[<span class="variable language_">this</span>.<span class="property">ajax</span>.<span class="title function_">bing</span>(<span class="variable language_">this</span>), <span class="literal">undefined</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 请求拦截</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">          chain.<span class="title function_">unshift</span>(interceptor.<span class="property">fillfield</span>, interceptor.<span class="property">rejected</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 响应拦截</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">interceptor</span> =&gt;</span> &#123;</span><br><span class="line">          chain.<span class="title function_">push</span>(interceptor.<span class="property">fillfield</span>, interceptor.<span class="property">rejected</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 执行队列</span></span><br><span class="line">        <span class="keyword">let</span> resolvePromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config)</span><br><span class="line">        <span class="keyword">while</span>(chain.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 不断对 config 从上一个promise传递到下一个 promise</span></span><br><span class="line">          <span class="comment">// Promise.resolve() 返回是一个新的 promise 对象</span></span><br><span class="line">          resolvePromise = resolvePromise.<span class="title function_">then</span>(chain.<span class="title function_">shift</span>(), chain.<span class="title function_">shift</span>()) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resolvePromise</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">ajax</span>(<span class="params">config</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;<span class="attr">url</span>:<span class="string">&quot;&quot;</span>, method=<span class="string">&quot;get&quot;</span>, data=&#123;&#125;&#125;=config</span><br><span class="line">            <span class="keyword">let</span> xhr=<span class="keyword">new</span>	<span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        	xhr.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">//请求成功时调用</span></span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.<span class="title function_">open</span>(method, url)</span><br><span class="line">            xhr.<span class="title function_">send</span>(daat)        </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义get,post...方法，挂在到Axios原型上</span></span><br><span class="line"><span class="comment">// 其实内部还是调用的Axios.request()方法</span></span><br><span class="line"><span class="keyword">let</span> methods=[<span class="string">&quot;get&quot;</span>, <span class="string">&quot;post&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;put&quot;</span>]</span><br><span class="line">methods.<span class="title function_">forEach</span>(<span class="function"><span class="params">met</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[met]=<span class="keyword">function</span>(<span class="params">url, method, data</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                <span class="attr">url</span>:url,</span><br><span class="line">                <span class="attr">method</span>:method,</span><br><span class="line">                <span class="attr">data</span>:data</span><br><span class="line">            &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现拦截器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorsManage</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>=[]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">use</span>(<span class="params">sucess, error</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">            sucess,</span><br><span class="line">            error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateAxiosFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> axios=<span class="keyword">new</span> <span class="title class_">Axios</span>()</span><br><span class="line">    <span class="keyword">let</span> req=axios.<span class="property">request</span>.<span class="title function_">bind</span>(axios)</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到最后的全局变量axios</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">GlobalAxios</span>=<span class="title class_">CreateAxiosFn</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">GlobalAxios</span>(&#123;</span><br><span class="line">    params</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是一种异步编程解决方案，解决了回调地狱问题。</p>
<h4 id="同步、异步、回调"><a href="#同步、异步、回调" class="headerlink" title="同步、异步、回调"></a>同步、异步、回调</h4><p>同步：等，直接拿结果</p>
<p>异步：先干其他事情，等结果返回了再去拿</p>
<p>回调（callback）：浏览器回头调用某一个函数</p>
<p>回调举例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的f1是回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f2</span>(f1)</span><br></pre></td></tr></table></figure>

<p>异步任务需要用回调函数通知结果</p>
<p>回调不一定只用于异步任务，还有同步任务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步回调</span></span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function"><span class="params">n</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(n))</span><br></pre></td></tr></table></figure>


<h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><p>回调地狱（多层异步操作），嵌套的写法代码结构不清晰:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取data1</span></span><br><span class="line">$.<span class="title function_">get</span>(url1, <span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data1);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// data1获取后再获取data2</span></span><br><span class="line">    $.<span class="title function_">get</span>(url2, <span class="function"><span class="params">data2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// data2获取后再获取data3</span></span><br><span class="line">        $.<span class="title function_">get</span>(url3, <span class="function"><span class="params">data3</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data3);</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">// ...可以无限重复</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>AJAx的回调(sucess、fail)写在里面，不清晰，不利于代码复用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">success</span>(request.<span class="property">responseText</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fail</span>(request.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了(链式写法):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timeOut = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;200 OK&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;timeout in &#x27;</span> + timeOut + <span class="string">&#x27; seconds.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">r</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;Done: &#x27;</span> + r);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;Failed: &#x27;</span> + reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Failed: timeout in 1.933597136826617 seconds.</span></span><br></pre></td></tr></table></figure>


<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>1.当所有结果成功返回时按照请求顺序返回成功;</p>
<p>2.当其中有一个失败方法时，则进入失败方法;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Primise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//成功时进入</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//失败时进入</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>应用场景：同时获取个人信息、好友列表，并行执行这两个任务</p>
<h5 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all"></a>实现Promise.all</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span>=<span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> num=<span class="number">0</span> <span class="comment">//成功个数</span></span><br><span class="line">        <span class="keyword">let</span> ans=[] <span class="comment">//记录每一个promise返回的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            arr[i].<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//成功时调用</span></span><br><span class="line">                ans[i]=res</span><br><span class="line">                num++</span><br><span class="line">                <span class="comment">//判断是否所有的primise都执行成功</span></span><br><span class="line">                <span class="keyword">if</span>(num===arr.<span class="property">length</span>)&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(ans)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//失败时调用</span></span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><ol>
<li>由最先返回的状态为结果，比如下面p1最先返回fullfield</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;P1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&#x27;P2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//&quot;P1&quot;</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>

<p>应用场景：为了容错，同时有两个异步任务读取用户信息，只需要获得先返回的结果即可</p>
<h5 id="实现Promise-race"><a href="#实现Promise-race" class="headerlink" title="实现Promise.race()"></a>实现Promise.race()</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span>=<span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">lenght</span>;i++)&#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(arr[i]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//成功时调用</span></span><br><span class="line">                <span class="title function_">resolve</span>(res)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">//失败时调用</span></span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：这里为什么不可以直接arr[i].then(resolve())?</p>
<h4 id="Promise的一些应用题"><a href="#Promise的一些应用题" class="headerlink" title="Promise的一些应用题"></a>Promise的一些应用题</h4><ol>
<li><p>异步加载图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loadImg=<span class="keyword">function</span>(<span class="params">url</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> img=<span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">        img.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;图片加载成功&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        img.<span class="property">onerror</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&quot;加载失败&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loadImg</span>(<span class="string">&quot;www.baidu.com&quot;</span>).<span class="title function_">then</span>()..........</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前请求依赖上一个请求结果时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getInfo</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//获取用户信息</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//获取店铺信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置图片请求超时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用第一个写好的loadImg函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setTimeOut</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;图片请求超时&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">5000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">loadImg</span>(), <span class="title function_">timeout</span>()]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//图片加载成功</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)<span class="comment">//图片请求超时</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用Promise实现每隔一秒输出123</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Timer</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="title class_">Timer</span>(<span class="number">2</span>)).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="title class_">Timer</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//async 版本</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title function_">_promise</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_promise</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(n)&#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Timer</span>(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

</li>
<li><p>异步并发数限制</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recur</span>(<span class="params">urls, limit, fn</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(urls.<span class="property">length</span>===<span class="number">0</span>)	<span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> n=limit</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">let</span> cur=urls.<span class="title function_">shift</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="title function_">fn</span>(cur).<span class="title function_">finally</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">recur</span>(urls, limit, fn)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">recur</span>(urls, limit, fn)</span><br></pre></td></tr></table></figure>


</li>
<li><p>异步加法</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">resolve</span>(a+b)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncAdd</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="keyword">await</span> <span class="title function_">add</span>(a, b)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncAdd</span>(<span class="number">6</span>,<span class="number">6</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Promise实现红绿灯交替重复亮</p>
</li>
</ol>
<p>红灯3秒亮一次，黄灯2秒亮一次，绿灯1秒亮一次；如何让三个灯不断交替重复亮灯？</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">red</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">green</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellow</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> light=<span class="keyword">function</span>(<span class="params">colorFn, timer</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">colorFn</span>()</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, timer)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">const</span> step = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">light</span>(red, <span class="number">3000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">light</span>(green, <span class="number">2000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">light</span>(yellow, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">step</span>()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">step</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">let</span> step=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">light</span>(red, <span class="number">3000</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">light</span>(green, <span class="number">2000</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">light</span>(yellow, <span class="number">1000</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">step</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">step</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>为什么2不对？</p>
<ol start="8">
<li><p>中断Promise</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在超过一段时间之后，把pending状态的promise给reject掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：给网络请求设置超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeOut</span>(<span class="params">p, limit=<span class="number">3000</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> wait=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;请求超时&#x27;</span>)</span><br><span class="line">        &#125;, limit)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([p, wait])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.all 和 Promise.allSettled 有什么区别</p>
</li>
</ol>
<p>当有一个promise出现异常，被reject 了，其余执行成功的promise的信息石沉大海</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">delay</span>=(<span class="params">n</span>)=&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">setTimeout</span>(resolve, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promises=[</span><br><span class="line">    <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="number">1</span>),</span><br><span class="line">    <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">()=&gt;</span><span class="number">2</span>),</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="comment">//最终输出： Uncaught (in promise) 3</span></span><br><span class="line"><span class="comment">//其他执行成功的Promise的消息都丢失了，仿佛石沉大海一般</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

所以这时候就要使用Promise.allSettled

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="comment">// 最终输出： </span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure>
</code></pre>
<p>因此，当用Promise.allSettled时，我们只需专注在then语句里，当有promise被异常打断时，我们依然能妥善处理那些已经成功了的promise，不必全部重来</p>
<h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h4><p>为了不用.then的链式调用的方式使用Promise，进一步加强代码可读性，引入了Async Await</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>())</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/profile&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//async await 可以让我们像同步一样写代码</span></span><br></pre></td></tr></table></figure>

<p>使用错误处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> f1 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>())</span><br><span class="line">        <span class="keyword">var</span> f2 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/profile&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error is&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> f1 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>())).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">        <span class="keyword">var</span> f2 = <span class="keyword">await</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/profile&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>())).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Promise的一些常识"><a href="#Promise的一些常识" class="headerlink" title="Promise的一些常识"></a>Promise的一些常识</h4><ul>
<li>Promise中的resolve后面的语句也是会执行的，如果不想执行，使用return</li>
<li>async返回的是一个Promise对象</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2022/07/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>




<h2 id="优化首屏加载速度"><a href="#优化首屏加载速度" class="headerlink" title="优化首屏加载速度"></a>优化首屏加载速度</h2><p>SPA（单页应用）首屏加载速度慢怎么解决: <a href="https://fe.ecool.fun/topic/a5032eb9-6a53-4792-852f-3f9417631c47?orderBy=updateTime&amp;order=desc&amp;titleKey=%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD">https://fe.ecool.fun/topic/a5032eb9-6a53-4792-852f-3f9417631c47?orderBy=updateTime&amp;order=desc&amp;titleKey=%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD</a></p>
<ul>
<li><p>UI框架按需加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Input</span>, <span class="title class_">Pagination</span>, <span class="title class_">Table</span>, <span class="title class_">TableColumn</span>, <span class="title class_">MessageBox</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Input</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Pagination</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由懒加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[ </span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;Blogs&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ShowBlogs&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./components/ShowBlogs.vue&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>只有在解析给定的路由时，才会加载路由组件</p>
<ul>
<li>组件重复打包</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">minChunks</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>


<ul>
<li>开启GZip压缩</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// gzip压缩</span></span><br><span class="line"> <span class="keyword">const</span> productionGzipExtensions = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]</span><br><span class="line"> config.<span class="property">plugins</span>.<span class="title function_">push</span>(</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">CompressionWebpackPlugin</span>(&#123;</span><br><span class="line">     <span class="attr">filename</span>: <span class="string">&#x27;[path].gz[query]&#x27;</span>,</span><br><span class="line">     <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">     <span class="attr">test</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">       <span class="string">&#x27;\\.(&#x27;</span> + productionGzipExtensions.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) + <span class="string">&#x27;)$&#x27;</span></span><br><span class="line">     ),</span><br><span class="line">     <span class="attr">threshold</span>: <span class="number">10240</span>, <span class="comment">// 只有大小大于该值的资源会被处理 10240</span></span><br><span class="line">     <span class="attr">minRatio</span>: <span class="number">0.8</span>, <span class="comment">// 只有压缩率小于这个值的资源才会被处理</span></span><br><span class="line">     <span class="attr">deleteOriginalAssets</span>: <span class="literal">false</span> <span class="comment">// 删除原文件</span></span><br><span class="line">   &#125;)</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ES6中的this</title>
    <url>/2022/07/29/ES6%E4%B8%AD%E7%9A%84this/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2022/07/29/HTTP/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h2><p>HTTP主要是为浏览器和服务器之间通信而设计的一种规则，提供一种发布和接受HTML页面的方法</p>
<h4 id="HTTP的组成"><a href="#HTTP的组成" class="headerlink" title="HTTP的组成"></a>HTTP的组成</h4><p>请求报文的组成</p>
<ol>
<li>请求行：包括请求方法（get、post、options等）、URL、协议&#x2F;版本</li>
<li>请求头(Request Header)：传输的类型Content-Type</li>
<li>请求正文</li>
</ol>
<p><img src="https://pic4.zhimg.com/v2-770cc76b2cb7da75d04a886015a9565b_r.jpg" alt="image-20220729095322778"></p>
<p>响应报文的组成</p>
<ol>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-58506e2188987db01ffb1589e208d83b_720w.jpg" alt="image-20220729095531132"></p>
<h4 id="Pose和Get的区别"><a href="#Pose和Get的区别" class="headerlink" title="Pose和Get的区别"></a>Pose和Get的区别</h4><ul>
<li>post比get多了请求体body</li>
<li>一般对get请求的数据进行缓存，因为缓存适用于不会更新服务端数据的请求</li>
</ul>
<h4 id="为什么说HTTP是无状态的协议？"><a href="#为什么说HTTP是无状态的协议？" class="headerlink" title="为什么说HTTP是无状态的协议？"></a>为什么说HTTP是无状态的协议？</h4><h4 id="什么时候会发送options请求"><a href="#什么时候会发送options请求" class="headerlink" title="什么时候会发送options请求"></a>什么时候会发送options请求</h4><p><strong>两个作用：</strong></p>
<ol>
<li>检测服务器所支持的请求方法</li>
<li>CORS中的预检请求</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 检测服务器所支持的请求方法</span></span><br><span class="line"><span class="comment">//发起options请求：curl -X OPTIONS http://example.org -i</span></span><br><span class="line"><span class="comment">//返回响应报文如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="comment">Allow: OPTIONS, GET, HEAD, POST</span></span><br><span class="line"><span class="comment">。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//其中的Allow首部字段，表明了服务器所支持的HTTP方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. CORS中的预检请求</span></span><br><span class="line"><span class="comment">// Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法</span></span><br><span class="line"><span class="comment">//Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段</span></span><br><span class="line"><span class="comment">//服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">OPTIONS /resources/post-here/ HTTP/1.1</span></span><br><span class="line"><span class="comment">Host: bar.other</span></span><br><span class="line"><span class="comment">。。。</span></span><br><span class="line"><span class="comment">Origin: http://foo.example</span></span><br><span class="line"><span class="comment">Access-Control-Request-Method: POST</span></span><br><span class="line"><span class="comment">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后返回的响应报文：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HTTP/1.1 200 OK</span></span><br><span class="line"><span class="comment">。。。</span></span><br><span class="line"><span class="comment">Access-Control-Allow-Methods: POST, GET, OPTIONS</span></span><br><span class="line"><span class="comment">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span></span><br><span class="line"><span class="comment">。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么要发送Options请求：</strong></p>
<p>检验服务器是否接受该跨域请求。</p>
<p>那些对服务器数据产生修改的HTTP方法 （除了GET以外的方法），浏览器必须先用Options发起预检请求，从而知道服务器是否允许该跨域请求。</p>
<p>由于安全原因，浏览器会在正式请求之前自动先发起OPTIONS预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</p>
<p><strong>优化Options请求：</strong></p>
<p>由于跨域的话，每次都要先发起Options请求，增加了请求次数，影响性能，以下2种方法提升性能：</p>
<ol>
<li>用JSONP做跨域请求</li>
<li><strong>缓存Option请求</strong></li>
</ol>
<p><strong>缓存Options预检请求：</strong></p>
<p>当第一次请求该URL时会发出<code>OPTIONS</code>请求，浏览器会根据返回的<code>Access-Control-Max-Age</code>字段缓存该请求的<code>OPTIONS预检请求</code>的响应结果。在缓存有效期内，该资源的请求（URL和header字段都相同的情况下）不会再触发预检。(chrome 打开控制台可以看到，当服务器响应<code>Access-Control-Max-Age</code> 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉<code>disable cache</code>勾选)</p>
<p>Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p><strong>为什么要用https</strong></p>
<ul>
<li>http存在一些问题：请求信息明文传输，比如账号密码；没有验证对方身份</li>
</ul>
<p>所以出现HTTPS&#x3D;HTTP+SSL，采用SSL证书验证服务器的身份，具体过程是：</p>
<ul>
<li><p>客户端发起连接请求</p>
</li>
<li><p>服务端返回证书（公钥）</p>
</li>
<li><p>客户端用公钥加密</p>
</li>
<li><p>服务端用私钥解密</p>
</li>
</ul>
<p><strong>总结HTTP和HTTPS的区别：</strong></p>
<p>参考：<a href="https://fe.ecool.fun/topic/8740bcd2-4a52-4c22-aed1-d573eb42dfa9?orderBy=updateTime&amp;order=desc&amp;titleKey=https">https://fe.ecool.fun/topic/8740bcd2-4a52-4c22-aed1-d573eb42dfa9?orderBy=updateTime&amp;order=desc&amp;titleKey=https</a></p>
<ul>
<li>HTTP协议数据明文传输，不安全</li>
<li>HTTPS协议利用SSL证书进行加密处理，安全</li>
</ul>
<p><strong>加密方法：</strong></p>
<p>参考：<a href="https://fe.ecool.fun/topic/8740bcd2-4a52-4c22-aed1-d573eb42dfa9?orderBy=updateTime&amp;order=desc&amp;titleKey=https">https://fe.ecool.fun/topic/8740bcd2-4a52-4c22-aed1-d573eb42dfa9?orderBy=updateTime&amp;order=desc&amp;titleKey=https</a></p>
<ul>
<li>对称密钥（加密解密用的同一个密钥）（缺点是一开始发送密钥时，可能会被坏人拦截）</li>
<li>非对称加密算法（类似于ssh密钥）（缺点是很慢）</li>
<li>非对称密钥+对称密钥</li>
</ul>
<p><strong>数字签名：</strong></p>
<p>参考:<a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p>
<p>暂时没看懂。</p>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p><strong>总体</strong></p>
<ul>
<li>2xx    请求成功</li>
<li>3xx    浏览器需做重定向才能正常处理请求    </li>
<li>4xx    客户端错误</li>
<li>5xx    服务器错误</li>
</ul>
<p><strong>分别</strong></p>
<ul>
<li>204    请求成功但返回空的内容</li>
<li>301    永久重定向。旧域名不再使用，重定向到新域名；比如未登录用户重定向到访问用户中心重定向到登录页面</li>
<li>302    临时重定向。比如在做活动时，登录到首页自动重定向到活动页面，但是这只是临时的重定向，活动可能在未来某一时刻结束</li>
<li>304    告诉浏览器直接使用缓存，返回的页面不包括内容部分，从而提高了网页性能</li>
<li>400    请求报文格式错误</li>
<li>401    未认证。比如用户未登录就发起请求</li>
<li>403    服务端拒绝访问。比如IP被加入黑名单；访问次数过多被防火墙拒绝了</li>
<li>404    服务器找不到该资源</li>
<li>503    服务器暂时处于超负载或正在进行停机维护，无法处理请求</li>
<li>504    代码执行超时，发生死循环了</li>
</ul>
<h4 id="HTTP2-0和HTTP1-0"><a href="#HTTP2-0和HTTP1-0" class="headerlink" title="HTTP2.0和HTTP1.0"></a>HTTP2.0和HTTP1.0</h4><h4 id="HTTP请求头（响应头）"><a href="#HTTP请求头（响应头）" class="headerlink" title="HTTP请求头（响应头）"></a>HTTP请求头（响应头）</h4><h4 id="HTTP缓存策略"><a href="#HTTP缓存策略" class="headerlink" title="HTTP缓存策略"></a>HTTP缓存策略</h4>]]></content>
  </entry>
</search>
